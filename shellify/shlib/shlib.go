// Copyright 2016 The Minimal Configuration Manager Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package shlib provides the functionality of the mcm-shellify tool.
package shlib

import (
	"crypto/sha1"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	slashpath "path"
	"strconv"

	"github.com/zombiezen/mcm/catalog"
	"github.com/zombiezen/mcm/internal/depgraph"
	"github.com/zombiezen/mcm/third_party/golang/capnproto"
)

// WriteScript converts a catalog into a bash script and writes it to w.
func WriteScript(w io.Writer, c catalog.Catalog) error {
	g := newGen(w)
	g.p(script("#!/bin/bash"))
	g.p(script("# Autogenerated by mcm-shellify"))
	g.p()
	res, _ := c.Resources()
	if res.Len() == 0 {
		g.p(script("# Empty catalog"))
		return g.ew.err
	}
	graph, err := depgraph.New(res)
	if err != nil {
		return err
	}
	for i := 0; i < res.Len(); i++ {
		r := res.At(i)
		if err := g.resourceFunc(r); err != nil {
			return fmt.Errorf("resource ID=%d: %v", r.ID(), err)
		}
	}
	g.supportLib()
	g.p(script("_() {"))
	g.in()
	for i := 0; i < res.Len(); i++ {
		v := resourceStatusVar(res.At(i).ID())
		g.p(assignment{v, -2})
	}
	for g.ew.err == nil && !graph.Done() {
		ready := append([]uint64(nil), graph.Ready()...)
		if len(ready) == 0 {
			return errors.New("graph not done, but has nothing to do")
		}
		for _, id := range ready {
			graph.Mark(id)
			deps, _ := graph.Resource(id).Dependencies()
			if deps.Len() == 0 {
				g.p(resourceFuncName(id))
				continue
			}
			g.p(script("if [["), depsPrecondition(deps), script("]]; then"))
			g.in()
			g.p(resourceFuncName(id))
			g.out()
			g.p(script("else"))
			g.in()
			g.p(assignment{resourceStatusVar(id), -1})
			g.out()
			g.p(script("fi"))
		}
	}
	g.exitStatusCheck(res)
	g.out()
	g.p(script("}"))
	g.p(script(`_ "$0" "$@"`))
	return g.ew.err
}

func (g *gen) supportLib() {
	// usage: setmode PATH MODE OWNER GROUP
	// Any one of MODE, OWNER, or GROUP can be omitted by passing "".
	// MODE must be an octal string with a leading zero.  OWNER and GROUP
	// denote a numeric ID by prefixing with ":".  stdout will be empty if
	// something changed, "noop" otherwise.
	if g.needsSetmode {
		g.literal(`setmode() {
	local changed=0
	local os="$(uname -s)"
	if [[ ! -z "$2" ]]; then
		local currmode
		currmode="0$([[ "$os" != Darwin ]] && stat -c '%a' "$1" || stat -f '%OMp%03OLp' "$1")"
		[[ $? -eq 0 ]] || return 1
		if [[ "$currmode" -ne "$2" ]]; then
			chmod "$2" "$1" && changed=1 || return 1
		fi
	fi
	local newowner="$3"
	local newgroup="$4"
	if [[ ! -z "$newowner" || ! -z "$newgroup" ]]; then
		local currowner
		if [[ "$newowner" = :* ]]; then
			newowner="${newowner:1}"
			currowner="$([[ "$os" != Darwin ]] && stat -c '%u' "$1" || stat -f '%Du' "$1")"
			[[ $? -eq 0 ]] || return 1
		elif [[ ! -z "$newowner" ]]; then
			currowner="$([[ "$os" != Darwin ]] && stat -c '%U' "$1" || stat -f '%Su' "$1")"
			[[ $? -eq 0 ]] || return 1
		fi
		local currgroup
		if [[ "$newgroup" = :* ]]; then
			newgroup="${newgroup:1}"
			currgroup="$([[ "$os" != Darwin ]] && stat -c '%g' "$1" || stat -f '%Dg' "$1")"
			[[ $? -eq 0 ]] || return 1
		elif [[ ! -z "$newgroup" ]]; then
			currgroup="$([[ "$os" != Darwin ]] && stat -c '%G' "$1" || stat -f '%Sg' "$1")"
			[[ $? -eq 0 ]] || return 1
		fi
		if [[ "$currowner" != "$newowner" || "$currgroup" != "$newgroup" ]]; then
			chown "${newowner}:${newgroup}" "$1" && changed=1 || return 1
		fi
	fi
	[[ $changed -ne 0 ]] || echo "noop"
	return 0
}`)
	}
}

func resourceStatusVar(id uint64) script {
	return script(fmt.Sprintf("status%d", id))
}

func resourceFuncName(id uint64) script {
	return script(fmt.Sprintf("resource%d", id))
}

func (g *gen) resourceFunc(r catalog.Resource) error {
	id := r.ID()
	if c, _ := r.Comment(); c != "" {
		// TODO(someday): trim newlines?
		g.p(script("#"), script(c))
	}
	g.p(resourceFuncName(id) + "() {")
	defer g.p(script("}"))
	g.in()
	defer g.out()

	if c, _ := r.Comment(); c != "" {
		g.p(script("echo"), fmt.Sprintf("applying: %s (id=%d)", c, r.ID()), script("1>&2"))
	} else {
		g.p(script("echo"), fmt.Sprintf("applying: id=%d", r.ID()), script("1>&2"))
	}
	statVar := resourceStatusVar(id)
	switch r.Which() {
	case catalog.Resource_Which_noop:
		if deps, _ := r.Dependencies(); deps.Len() > 0 {
			g.p(script("[["), depsChangedCondition(deps), script("]] &&"), assignment{statVar, 1}, script("||"), assignment{statVar, 0})
		} else {
			g.p(assignment{statVar, 0})
		}
		return nil
	case catalog.Resource_Which_file:
		f, err := r.File()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		return g.file(id, f)
	case catalog.Resource_Which_exec:
		e, err := r.Exec()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		return g.exec(id, e)
	default:
		return fmt.Errorf("unsupported resource %v", r.Which())
	}
}

func depsPrecondition(deps capnp.UInt64List) script {
	var buf []byte
	for i, n := 0, deps.Len(); i < n; i++ {
		if i > 0 {
			buf = append(buf, " && "...)
		}
		buf = append(buf, "$status"...)
		buf = strconv.AppendUint(buf, deps.At(i), 10)
		buf = append(buf, " -ge 0"...)
	}
	return script(buf)
}

func depsChangedCondition(deps capnp.UInt64List) script {
	var buf []byte
	for i, n := 0, deps.Len(); i < n; i++ {
		if i > 0 {
			buf = append(buf, " || "...)
		}
		buf = append(buf, "$status"...)
		buf = strconv.AppendUint(buf, deps.At(i), 10)
		buf = append(buf, " -gt 0"...)
	}
	return script(buf)
}

func (g *gen) exitStatusCheck(res catalog.Resource_List) {
	var buf []byte
	for i, n := 0, res.Len(); i < n; i++ {
		if i > 0 {
			buf = append(buf, " || "...)
		}
		buf = append(buf, "$status"...)
		buf = strconv.AppendUint(buf, res.At(i).ID(), 10)
		buf = append(buf, " -lt 0"...)
	}
	g.p(script("if [["), script(buf), script("]]; then"))
	g.in()
	g.p(script("return 1"))
	g.out()
	g.p(script("fi"))
	g.p(script("return 0"))
}

func updateStatus(id uint64) script {
	var buf []byte
	buf = append(buf, "&& "...)
	v := resourceStatusVar(id)
	buf = appendPArg(buf, assignment{v, 1})
	buf = append(buf, " || "...)
	buf = appendPArg(buf, assignment{v, -1})
	return script(buf)
}

func (g *gen) returnStatus(id uint64, val int) {
	g.p(assignment{resourceStatusVar(id), val})
	if val >= 0 {
		g.p(script("return 0"))
	} else {
		g.p(script("return 1"))
	}
}

func resourceFuncReturn(id uint64) script {
	var buf []byte
	buf = append(buf, "[[ $"...)
	buf = append(buf, resourceStatusVar(id)...)
	buf = append(buf, " -ge 0 ]] && return 0 || return 1"...)
	return script(buf)
}

func (g *gen) file(id uint64, f catalog.File) error {
	path, err := f.Path()
	if err != nil {
		return fmt.Errorf("reading file path: %v", err)
	}
	if path == "" {
		return errors.New("file path is empty")
	}
	if !slashpath.IsAbs(path) {
		return fmt.Errorf("%s is not an absolute path", path)
	}
	g.p(script("local"), assignment{"respath", path})

	switch f.Which() {
	case catalog.File_Which_plain:
		g.p(script(`if [[ -h "$respath" ]]; then`))
		g.in()
		g.p(script(`echo "$respath is not a regular file" 1>&2`))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		m, _ := f.Plain().Mode()
		margs, err := modeToArgs(m)
		if err != nil {
			return err
		}
		switch {
		case f.Plain().HasContent() && !margs.isEmpty():
			content, err := f.Plain().Content()
			if err != nil {
				return fmt.Errorf("read content from catalog: %v", err)
			}
			g.fileContent(id, content)

			// If normal file, then check content for need to replace file.
			g.p(script("local chcontent=1"))
			g.p(script(`if [[ -f "$respath" ]]; then`))
			g.in()
			g.p(script("local cmpresult"))
			g.p(script(`cmp -s "$tmploc" "$respath"`))
			g.p(script("cmpresult=$?"))
			g.p(script("if [[ $cmpresult -eq 0 ]]; then"))
			g.in()
			g.p(script(`rm "$tmploc"`))
			g.p(script("chcontent=0"))
			g.out()
			g.p(script("elif [[ $cmpresult -ne 1 ]]; then"))
			g.in()
			g.p(script(`rm "$tmploc"`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			g.out()
			// and non-fileness.
			g.p(script(`elif [[ -e "$respath" ]]; then`))
			g.in()
			g.p(script(`echo "$respath is not a regular file" 1>&2`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))

			// Replace file if necessary.
			g.p(script("if [[ $chcontent -eq 1 ]]; then"))
			g.in()
			g.p(script(`mv "$tmploc" "$respath"`))
			g.p(script("local mvfail=$?"))
			g.p(script(`rm -f "$tmploc"`))
			g.p(script("if [[ $mvfail -ne 0 ]]; then"))
			g.in()
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			g.out()
			g.p(script("fi"))

			// Set file mode.
			g.needsSetmode = true
			g.p(script("local modeout"))
			g.p(assignment{"modeout", script("\"$(") + margs.script(script("\"$respath\"")) + script(")\"")})
			g.p(script("if [[ $? -ne 0 ]]; then"))
			g.in()
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			v := resourceStatusVar(id)
			g.p(script(`[[ $chcontent -eq 1 || "$modeout" != 'noop' ]] &&`), assignment{v, 1}, script("||"), assignment{v, 0})
			g.p(resourceFuncReturn(id))
		case f.Plain().HasContent():
			content, err := f.Plain().Content()
			if err != nil {
				return fmt.Errorf("read content from catalog: %v", err)
			}
			g.fileContent(id, content)

			// Check for existence...
			g.p(script(`if [[ ! -e "$respath" ]]; then`))
			g.in()
			g.p(script(`mv "$tmploc" "$respath"`), updateStatus(id))
			g.p(script(`rm -f "$tmploc"`))
			g.p(resourceFuncReturn(id))
			g.out()
			// and non-fileness.
			g.p(script(`elif [[ ! -f "$respath" ]]; then`))
			g.in()
			g.p(script(`echo "$respath is not a regular file" 1>&2`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))

			// Compare to what's already there.
			// If identical, return success.  If comparison fails, abort.
			g.p(script("local cmpresult"))
			g.p(script(`cmp -s "$tmploc" "$respath"`))
			g.p(script("cmpresult=$?"))
			g.p(script("if [[ $cmpresult -eq 0 ]]; then"))
			g.in()
			g.p(script(`rm "$tmploc"`))
			g.returnStatus(id, 0)
			g.out()
			g.p(script("elif [[ $cmpresult -ne 1 ]]; then"))
			g.in()
			g.p(script(`rm "$tmploc"`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))

			// Replace existing file with new one.
			g.p(script(`mv "$tmploc" "$respath"`), updateStatus(id))
			g.p(script(`rm -f "$tmploc"`))
			g.p(resourceFuncReturn(id))
		case !margs.isEmpty():
			g.p(script(`if [[ ! -f "$respath" ]]; then`))
			g.in()
			g.p(script(`echo "$respath is not a regular file" 1>&2`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))

			g.needsSetmode = true
			g.p(script("local modeout"))
			g.p(assignment{"modeout", script("\"$(") + margs.script(script("\"$respath\"")) + script(")\"")})
			g.p(script("if [[ $? -ne 0 ]]; then"))
			g.in()
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			v := resourceStatusVar(id)
			g.p(script(`[[ "$modeout" != 'noop' ]] &&`), assignment{v, 1}, script("||"), assignment{v, 0})
			g.p(resourceFuncReturn(id))
		default:
			g.p(script(`if [[ ! -f "$respath" ]]; then`))
			g.in()
			g.p(script(`echo "$respath is not a regular file" 1>&2`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			g.returnStatus(id, 0)
		}
	case catalog.File_Which_directory:
		m, _ := f.Directory().Mode()
		margs, err := modeToArgs(m)
		if err != nil {
			return err
		}

		if margs.isEmpty() {
			g.p(script(`if [[ -d "$respath" ]]; then`))
			g.in()
			g.returnStatus(id, 0)
			g.out()
			g.p(script(`elif [[ -e "$respath" ]]; then`))
			g.in()
			g.p(script(`echo "$respath is not a directory" 1>&2`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			g.p(script(`mkdir "$respath"`), updateStatus(id))
			g.p(resourceFuncReturn(id))
		} else {
			g.p(script("local needmkdir=1"))
			g.p(script(`if [[ -d "$respath" ]]; then`))
			g.in()
			g.p(script("needmkdir=0"))
			g.out()
			g.p(script(`elif [[ -e "$respath" ]]; then`))
			g.in()
			g.p(script(`echo "$respath is not a directory" 1>&2`))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			g.p(script(`mkdir "$respath"`))
			g.p(script("if [[ $? -ne 0 ]]; then"))
			g.in()
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))

			g.needsSetmode = true
			g.p(script("local modeout"))
			g.p(assignment{"modeout", script("\"$(") + margs.script(script("\"$respath\"")) + script(")\"")})
			g.p(script("if [[ $? -ne 0 ]]; then"))
			g.in()
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			v := resourceStatusVar(id)
			g.p(script(`[[ $needmkdir -eq 1 || "$modeout" != 'noop' ]] &&`), assignment{v, 1}, script("||"), assignment{v, 0})
			g.p(resourceFuncReturn(id))
		}
	case catalog.File_Which_symlink:
		target, _ := f.Symlink().Target()
		if target == "" {
			return errors.New("symlink target is empty")
		}
		g.p(script("local"), assignment{"tgt", target})
		g.p(script(`if [[ -h "$respath" ]]; then`))
		g.in()
		g.p(script(`if [[ "$(readlink "$respath")" != "$tgt" ]]; then`))
		g.in()
		g.p(script(`ln -f -s "$tgt" "$respath"`), updateStatus(id))
		g.p(resourceFuncReturn(id))
		g.out()
		g.p(script("else"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
		g.out()
		g.p(script("fi"))

		g.p(script(`if [[ -e "$respath" ]]; then`))
		g.in()
		g.p(script(`echo "$respath is not a symlink" 1>&2`))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		g.p(script(`ln -s "$tgt" "$respath"`), updateStatus(id))
		g.p(resourceFuncReturn(id))
	default:
		return fmt.Errorf("unsupported file directive %v", f.Which())
	}
	return nil
}

// fileContent is a macro for writing data to a temporary file.
// This creates a local variable called "tmploc" that has the path of
// the new file.
func (g *gen) fileContent(id uint64, content []byte) {
	enc := make([]byte, base64.StdEncoding.EncodedLen(len(content)))
	base64.StdEncoding.Encode(enc, content)
	g.p(script("local tmploc"))
	g.p(assignment{"tmploc", script(`"$(mktemp 2>/dev/null || mktemp -t tmp)"`)})
	g.p(script("if [[ $? -ne 0 ]]; then"))
	g.in()
	g.returnStatus(id, -1)
	g.out()
	g.p(script("fi"))
	// TODO(someday): non-binary files could skip base64 decoding.
	g.p(script(`base64 --decode > "$tmploc"`), heredoc{marker: "!EOF!", data: enc})
	g.p(script("if [[ $? -ne 0 ]]; then"))
	g.in()
	g.p(script(`rm "$tmploc"`))
	g.returnStatus(id, -1)
	g.out()
	g.p(script("fi"))
}

type setmodeArgs struct {
	mode  string
	user  string
	group string
}

func (a setmodeArgs) isEmpty() bool {
	return a == setmodeArgs{}
}

func (a setmodeArgs) script(path interface{}) script {
	var buf []byte
	buf = append(buf, "setmode "...)
	buf = appendPArg(buf, path)
	buf = append(buf, ' ')
	buf = appendPArg(buf, a.mode)
	buf = append(buf, ' ')
	buf = appendPArg(buf, a.user)
	buf = append(buf, ' ')
	buf = appendPArg(buf, a.group)
	return script(buf)
}

func modeToArgs(mode catalog.File_Mode) (setmodeArgs, error) {
	var args setmodeArgs
	if mode.Bits() != catalog.File_Mode_unset {
		args.mode = fmt.Sprintf("%#o", mode.Bits())
	}

	user, err := mode.User()
	if err != nil {
		return setmodeArgs{}, fmt.Errorf("read mode user: %v", err)
	}
	switch user.Which() {
	case catalog.UserRef_Which_ID:
		id := user.ID()
		if id < -1 {
			return setmodeArgs{}, fmt.Errorf("invalid mode user ID %d", id)
		}
		if id != -1 {
			args.user = fmt.Sprintf(":%d", id)
		}
	case catalog.UserRef_Which_name:
		var err error
		args.user, err = user.Name()
		if err != nil {
			return setmodeArgs{}, fmt.Errorf("read mode user: %v", err)
		}
	default:
		return setmodeArgs{}, fmt.Errorf("unknown user ref %v", user.Which())
	}

	group, err := mode.Group()
	if err != nil {
		return setmodeArgs{}, fmt.Errorf("read mode group: %v", err)
	}
	switch group.Which() {
	case catalog.GroupRef_Which_ID:
		id := group.ID()
		if id < -1 {
			return setmodeArgs{}, fmt.Errorf("invalid mode group ID %d", id)
		}
		if id != -1 {
			args.group = fmt.Sprintf(":%d", id)
		}
	case catalog.GroupRef_Which_name:
		var err error
		args.group, err = group.Name()
		if err != nil {
			return setmodeArgs{}, fmt.Errorf("read mode group: %v", err)
		}
	default:
		return setmodeArgs{}, fmt.Errorf("unknown group ref %v", group.Which())
	}

	return args, nil
}

func (g *gen) exec(id uint64, e catalog.Exec) error {
	if err := g.execCondition(id, e.Condition()); err != nil {
		return fmt.Errorf("condition: %v", err)
	}
	c, err := e.Command()
	if err != nil {
		return fmt.Errorf("read command from catalog: %v", err)
	}
	g.p(script("local commandExit"))
	if err := g.command("commandExit", c); err != nil {
		return fmt.Errorf("command: %v", err)
	}
	g.p(script("[[ $commandExit -eq 0 ]]"), updateStatus(id))
	g.p(resourceFuncReturn(id))
	return nil
}

func (g *gen) execCondition(id uint64, cond catalog.Exec_condition) error {
	switch cond.Which() {
	case catalog.Exec_condition_Which_always:
		// Do nothing, always run.
	case catalog.Exec_condition_Which_onlyIf:
		g.p(script("local conditionExit"))
		c, err := cond.OnlyIf()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		if err := g.command("conditionExit", c); err != nil {
			return err
		}
		g.p(script("if [[ $conditionExit -ne 0 ]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	case catalog.Exec_condition_Which_unless:
		g.p(script("local conditionExit"))
		c, err := cond.Unless()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		if err := g.command("conditionExit", c); err != nil {
			return err
		}
		g.p(script("if [[ $conditionExit -eq 0 ]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	case catalog.Exec_condition_Which_fileAbsent:
		path, err := cond.FileAbsent()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		if path == "" {
			return errors.New("file absent path is empty")
		}
		if !slashpath.IsAbs(path) {
			return fmt.Errorf("%s is not an absolute path", path)
		}
		g.p(script("if [[ -e"), path, script("]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	case catalog.Exec_condition_Which_ifDepsChanged:
		// TODO(someday): validate that deps exist
		deps, _ := cond.IfDepsChanged()
		if deps.Len() == 0 {
			return errors.New("deps changed list is empty")
		}
		g.p(script("if ! [["), depsChangedCondition(deps), script("]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	default:
		return fmt.Errorf("unknown condition %v", cond.Which())
	}
	return nil
}

func (g *gen) command(statusVar script, c catalog.Exec_Command) error {
	wd, _ := c.WorkingDirectory()
	if wd == "" {
		wd = "/"
	}
	pargs := []interface{}{
		script("cd"), wd, script("&&"),
		script("env -"),
	}
	env, _ := c.Environment()
	for i, n := 0, env.Len(); i < n; i++ {
		k, err := env.At(i).Name()
		if err != nil {
			return fmt.Errorf("read environment[%d] from catalog: %v", i, err)
		}
		id, err := sanitizeIdentifier(k)
		if err != nil {
			return err
		}
		v, err := env.At(i).Value()
		if err != nil {
			return fmt.Errorf("read environment[%d] from catalog: %v", i, err)
		}
		pargs = append(pargs, assignment{id, v})
	}

	switch c.Which() {
	case catalog.Exec_Command_Which_argv:
		argv, err := c.Argv()
		if err != nil {
			return fmt.Errorf("read argv from catalog: %v", err)
		}
		if argv.Len() == 0 {
			return errors.New("command argv list is empty")
		}
		x, err := argv.At(0)
		if err != nil {
			return fmt.Errorf("read argv from catalog: %v", err)
		}
		if !slashpath.IsAbs(x) {
			return fmt.Errorf("%s in argv is not an absolute path", x)
		}
		pargs = append(pargs, x)
		for i, n := 1, argv.Len(); i < n; i++ {
			arg, err := argv.At(i)
			if err != nil {
				return fmt.Errorf("read argv from catalog: %v", err)
			}
			pargs = append(pargs, arg)
		}

		g.p(script("("))
		g.p(pargs...)
		g.p(script(")"))
		g.p(assignment{statusVar, script("$?")})
	case catalog.Exec_Command_Which_bash:
		b, err := c.BashBytes()
		if err != nil {
			return fmt.Errorf("read bash from catalog: %v", err)
		}
		pargs = append(pargs, script("bash"), heredoc{marker: contentMarker(b), data: b})

		g.p(script("("))
		g.p(pargs...)
		g.p(script(")"))
		g.p(assignment{statusVar, script("$?")})
	default:
		return fmt.Errorf("unsupported command %v", c.Which())
	}
	return nil
}

func contentMarker(b []byte) string {
	// TODO(someday): in most cases, EOF is fine.
	s := sha1.Sum(b)
	return "EOF" + hex.EncodeToString(s[:])
}
