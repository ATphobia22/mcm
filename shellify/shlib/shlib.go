// Copyright 2016 The Minimal Configuration Manager Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package shlib provides the functionality of the mcm-shellify tool.
package shlib

import (
	"crypto/sha1"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	slashpath "path"
	"strconv"

	"github.com/zombiezen/mcm/catalog"
	"github.com/zombiezen/mcm/internal/depgraph"
	"github.com/zombiezen/mcm/third_party/golang/capnproto"
)

// WriteScript converts a catalog into a bash script and writes it to w.
func WriteScript(w io.Writer, c catalog.Catalog) error {
	g := newGen(w)
	g.p(script("#!/bin/bash"))
	g.p(script("# Autogenerated by mcm-shellify"))
	g.p()
	res, _ := c.Resources()
	if res.Len() == 0 {
		g.p(script("# Empty catalog"))
		return g.ew.err
	}
	graph, err := depgraph.New(res)
	if err != nil {
		return err
	}
	for i := 0; i < res.Len(); i++ {
		r := res.At(i)
		if err := g.resourceFunc(r); err != nil {
			return fmt.Errorf("resource ID=%d: %v", r.ID(), err)
		}
	}
	g.p(script("_() {"))
	g.in()
	for i := 0; i < res.Len(); i++ {
		v := resourceStatusVar(res.At(i).ID())
		g.p(assignment{v, -2})
	}
	for g.ew.err == nil && !graph.Done() {
		ready := append([]uint64(nil), graph.Ready()...)
		if len(ready) == 0 {
			return errors.New("graph not done, but has nothing to do")
		}
		for _, id := range ready {
			graph.Mark(id)
			deps, _ := graph.Resource(id).Dependencies()
			if deps.Len() == 0 {
				g.p(resourceFuncName(id))
				continue
			}
			g.p(script("if [["), depsPrecondition(deps), script("]]; then"))
			g.in()
			g.p(resourceFuncName(id))
			g.out()
			g.p(script("else"))
			g.in()
			g.p(assignment{resourceStatusVar(id), -1})
			g.out()
			g.p(script("fi"))
		}
	}
	g.exitStatusCheck(res)
	g.out()
	g.p(script("}"))
	g.p(script(`_ "$0" "$@"`))
	return g.ew.err
}

func resourceStatusVar(id uint64) script {
	return script(fmt.Sprintf("status%d", id))
}

func resourceFuncName(id uint64) script {
	return script(fmt.Sprintf("resource%d", id))
}

func (g *gen) resourceFunc(r catalog.Resource) error {
	id := r.ID()
	if c, _ := r.Comment(); c != "" {
		// TODO(someday): trim newlines?
		g.p(script("#"), script(c))
	}
	g.p(resourceFuncName(id) + "() {")
	defer g.p(script("}"))
	g.in()
	defer g.out()

	statVar := resourceStatusVar(id)
	switch r.Which() {
	case catalog.Resource_Which_noop:
		if deps, _ := r.Dependencies(); deps.Len() > 0 {
			g.p(depsChangedCondition(deps), script("&&"), assignment{statVar, 1}, script("||"), assignment{statVar, 0})
		} else {
			g.p(assignment{statVar, 0})
		}
		return nil
	case catalog.Resource_Which_file:
		f, err := r.File()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		return g.file(id, f)
	case catalog.Resource_Which_exec:
		e, err := r.Exec()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		return g.exec(id, e)
	default:
		return fmt.Errorf("unsupported resource %v", r.Which())
	}
}

func depsPrecondition(deps capnp.UInt64List) script {
	var buf []byte
	for i, n := 0, deps.Len(); i < n; i++ {
		if i > 0 {
			buf = append(buf, " && "...)
		}
		buf = append(buf, "$status"...)
		buf = strconv.AppendUint(buf, deps.At(i), 10)
		buf = append(buf, " -ge 0"...)
	}
	return script(buf)
}

func depsChangedCondition(deps capnp.UInt64List) script {
	var buf []byte
	for i, n := 0, deps.Len(); i < n; i++ {
		if i > 0 {
			buf = append(buf, " || "...)
		}
		buf = append(buf, "$status"...)
		buf = strconv.AppendUint(buf, deps.At(i), 10)
		buf = append(buf, " -gt 0"...)
	}
	return script(buf)
}

func (g *gen) exitStatusCheck(res catalog.Resource_List) {
	var buf []byte
	for i, n := 0, res.Len(); i < n; i++ {
		if i > 0 {
			buf = append(buf, " || "...)
		}
		buf = append(buf, "$status"...)
		buf = strconv.AppendUint(buf, res.At(i).ID(), 10)
		buf = append(buf, " -lt 0"...)
	}
	g.p(script("if [["), script(buf), script("]]; then"))
	g.in()
	g.p(script("return 1"))
	g.out()
	g.p(script("fi"))
	g.p(script("return 0"))
}

func updateStatus(id uint64) script {
	var buf []byte
	buf = append(buf, "&& "...)
	v := resourceStatusVar(id)
	buf = appendPArg(buf, assignment{v, 1})
	buf = append(buf, " || "...)
	buf = appendPArg(buf, assignment{v, -1})
	return script(buf)
}

func (g *gen) returnStatus(id uint64, val int) {
	g.p(assignment{resourceStatusVar(id), val})
	if val >= 0 {
		g.p(script("return 0"))
	} else {
		g.p(script("return 1"))
	}
}

func resourceFuncReturn(id uint64) script {
	var buf []byte
	buf = append(buf, "[[ $"...)
	buf = append(buf, resourceStatusVar(id)...)
	buf = append(buf, " -ge 0 ]] && return 0 || return 1"...)
	return script(buf)
}

func (g *gen) file(id uint64, f catalog.File) error {
	path, err := f.Path()
	if err != nil {
		return fmt.Errorf("reading file path: %v", err)
	}
	if path == "" {
		return errors.New("file path is empty")
	}
	if !slashpath.IsAbs(path) {
		return fmt.Errorf("%s is not an absolute path", path)
	}
	switch f.Which() {
	case catalog.File_Which_plain:
		g.p(script("if [[ -h"), path, script("]]; then"))
		g.in()
		g.p(script("echo"), path, script("'is not a regular file' 1>&2"))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		if !f.Plain().HasContent() {
			g.p(script("if [[ ! -f"), path, script("]]; then"))
			g.in()
			g.p(script("echo"), path, script("'is not a regular file' 1>&2"))
			g.returnStatus(id, -1)
			g.out()
			g.p(script("fi"))
			g.returnStatus(id, 0)
			return nil
		}

		// Write content to a temporary file
		// Saves size in resulting script, since base64 is encoded only once.
		content, err := f.Plain().Content()
		if err != nil {
			return fmt.Errorf("read content from catalog: %v", err)
		}
		enc := make([]byte, base64.StdEncoding.EncodedLen(len(content)))
		base64.StdEncoding.Encode(enc, content)
		g.p(script("local tmploc"))
		g.p(assignment{"tmploc", script(`"$(mktemp 2>/dev/null || mktemp -t tmp)"`)})
		g.p(script("if [[ $? -ne 0 ]]; then"))
		g.in()
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))
		// TODO(someday): non-binary files could skip base64 decoding.
		g.p(script(`base64 --decode > "$tmploc"`), heredoc{marker: "!EOF!", data: enc})
		g.p(script("if [[ $? -ne 0 ]]; then"))
		g.in()
		g.p(script(`rm "$tmploc"`))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		// Check for existence...
		g.p(script("if [[ ! -e"), path, script("]]; then"))
		g.in()
		g.p(script(`mv "$tmploc"`), path, updateStatus(id))
		g.p(script(`rm -f "$tmploc"`))
		g.p(resourceFuncReturn(id))
		g.out()
		// and non-fileness.
		g.p(script("elif [[ ! -f"), path, script("]]; then"))
		g.in()
		g.p(script("echo"), path, script("'is not a regular file' 1>&2"))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		// Compare to what's already there.
		// If identical, return success.  If comparison fails, abort.
		g.p(script("local cmpresult"))
		g.p(script(`cmp -s "$tmploc"`), path)
		g.p(script("cmpresult=$?"))
		g.p(script("if [[ $cmpresult -eq 0 ]]; then"))
		g.in()
		g.p(script(`rm "$tmploc"`))
		g.returnStatus(id, 0)
		g.out()
		g.p(script("elif [[ $cmpresult -ne 1 ]]; then"))
		g.in()
		g.p(script(`rm "$tmploc"`))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		// Replace existing file with new one.
		g.p(script(`mv "$tmploc"`), path, updateStatus(id))
		g.p(script(`rm -f "$tmploc"`))
		g.p(resourceFuncReturn(id))
	case catalog.File_Which_directory:
		// TODO(someday): respect file mode
		g.p(script("if [[ -d"), path, script("]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
		g.p(script("if [[ -e"), path, script("]]; then"))
		g.in()
		g.p(script("echo"), path, script("'is not a directory' 1>&2"))
		g.returnStatus(id, -1)
		g.out()
		g.p("fi")
		g.p(script("mkdir"), path, updateStatus(id))
		g.p(resourceFuncReturn(id))
	case catalog.File_Which_symlink:
		target, _ := f.Symlink().Target()
		if target == "" {
			return errors.New("symlink target is empty")
		}
		g.p(script("if [[ -h"), path, script("]]; then"))
		g.in()
		g.p(script("if [[ \"$(readlink"), path, script(")\" !="), target, script("]]; then"))
		g.in()
		g.p(script("ln -f -s"), target, path, updateStatus(id))
		g.p(resourceFuncReturn(id))
		g.out()
		g.p(script("else"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
		g.out()
		g.p(script("fi"))

		g.p(script("if [[ -e"), path, script("]]; then"))
		g.in()
		g.p(script("echo"), path, script("'is not a symlink' 1>&2"))
		g.returnStatus(id, -1)
		g.out()
		g.p(script("fi"))

		g.p(script("ln -s"), target, path, updateStatus(id))
		g.p(resourceFuncReturn(id))
	default:
		return fmt.Errorf("unsupported file directive %v", f.Which())
	}
	return nil
}

func (g *gen) exec(id uint64, e catalog.Exec) error {
	if err := g.execCondition(id, e.Condition()); err != nil {
		return fmt.Errorf("condition: %v", err)
	}
	c, err := e.Command()
	if err != nil {
		return fmt.Errorf("read command from catalog: %v", err)
	}
	g.p(script("local commandExit"))
	if err := g.command("commandExit", c); err != nil {
		return fmt.Errorf("command: %v", err)
	}
	g.p(script("[[ $commandExit -eq 0 ]]"), updateStatus(id))
	g.p(resourceFuncReturn(id))
	return nil
}

func (g *gen) execCondition(id uint64, cond catalog.Exec_condition) error {
	switch cond.Which() {
	case catalog.Exec_condition_Which_always:
		// Do nothing, always run.
	case catalog.Exec_condition_Which_onlyIf:
		g.p(script("local conditionExit"))
		c, err := cond.OnlyIf()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		if err := g.command("conditionExit", c); err != nil {
			return err
		}
		g.p(script("if [[ $conditionExit -eq 0 ]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	case catalog.Exec_condition_Which_unless:
		g.p(script("local conditionExit"))
		c, err := cond.OnlyIf()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		if err := g.command("conditionExit", c); err != nil {
			return err
		}
		g.p(script("if [[ $conditionExit -ne 0 ]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	case catalog.Exec_condition_Which_fileAbsent:
		path, err := cond.FileAbsent()
		if err != nil {
			return fmt.Errorf("read from catalog: %v", err)
		}
		if path == "" {
			return errors.New("file absent path is empty")
		}
		if !slashpath.IsAbs(path) {
			return fmt.Errorf("%s is not an absolute path", path)
		}
		g.p(script("if [[ -e"), path, script("]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	case catalog.Exec_condition_Which_ifDepsChanged:
		// TODO(someday): validate that deps exist
		deps, _ := cond.IfDepsChanged()
		if deps.Len() == 0 {
			return errors.New("deps changed list is empty")
		}
		g.p(script("if ! [["), depsChangedCondition(deps), script("]]; then"))
		g.in()
		g.returnStatus(id, 0)
		g.out()
		g.p(script("fi"))
	default:
		return fmt.Errorf("unknown condition %v", cond.Which())
	}
	return nil
}

func (g *gen) command(statusVar script, c catalog.Exec_Command) error {
	wd, _ := c.WorkingDirectory()
	if wd == "" {
		wd = "/"
	}
	pargs := []interface{}{
		script("cd"), wd, script("&&"),
		script("env -"),
	}
	env, _ := c.Environment()
	for i, n := 0, env.Len(); i < n; i++ {
		k, err := env.At(i).Name()
		if err != nil {
			return fmt.Errorf("read environment[%d] from catalog: %v", i, err)
		}
		id, err := sanitizeIdentifier(k)
		if err != nil {
			return err
		}
		v, err := env.At(i).Value()
		if err != nil {
			return fmt.Errorf("read environment[%d] from catalog: %v", i, err)
		}
		pargs = append(pargs, assignment{id, v})
	}

	switch c.Which() {
	case catalog.Exec_Command_Which_argv:
		argv, err := c.Argv()
		if err != nil {
			return fmt.Errorf("read argv from catalog: %v", err)
		}
		if argv.Len() == 0 {
			return errors.New("command argv list is empty")
		}
		x, err := argv.At(0)
		if err != nil {
			return fmt.Errorf("read argv from catalog: %v", err)
		}
		if !slashpath.IsAbs(x) {
			return fmt.Errorf("%s in argv is not an absolute path", x)
		}
		pargs = append(pargs, x)
		for i, n := 1, argv.Len(); i < n; i++ {
			arg, err := argv.At(i)
			if err != nil {
				return fmt.Errorf("read argv from catalog: %v", err)
			}
			pargs = append(pargs, arg)
		}

		g.p(script("("))
		g.p(pargs...)
		g.p(script(")"))
		g.p(assignment{statusVar, script("$?")})
	case catalog.Exec_Command_Which_bash:
		b, err := c.BashBytes()
		if err != nil {
			return fmt.Errorf("read bash from catalog: %v", err)
		}
		pargs = append(pargs, script("bash"), heredoc{marker: contentMarker(b), data: b})

		g.p(script("("))
		g.p(pargs...)
		g.p(script(")"))
		g.p(assignment{statusVar, script("$?")})
	default:
		return fmt.Errorf("unsupported command %v", c.Which())
	}
	return nil
}

func contentMarker(b []byte) string {
	// TODO(someday): in most cases, EOF is fine.
	s := sha1.Sum(b)
	return "EOF" + hex.EncodeToString(s[:])
}
